package com.aptosstbbq.bbqapp.menu;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;

public class BBQMenu {

	/**
	 * Allows outside code to listen to BBQMenu events. This is useful when triggering events in GUI code. When the menu is reset, a new item is added, or an error occurs, the BBQMenuEvent method is called.
	 */
	public static interface Listener {
		public void BBQMenuEvent(BBQMenu menu, Event event, Object arg);
	}

	public static enum Event {
		ERROR, RESET, ADD_INGREDIENT, ADD_ITEM, ADD_CAT, CHANGE_INGREDIENT, CHANGE_ITEM, CHANGE_CAT;
	}

	private void fireEvent(Event event, Object arg) {
		for (Listener l : listeners) {
			l.BBQMenuEvent(this, event, arg);
		}
	}

	private transient List<Listener> listeners = new LinkedList<Listener>();

	private List<Ingredient> ingredients = new ArrayList<Ingredient>();
	private List<BBQMenuItem> menuItems = new ArrayList<BBQMenuItem>();
	private List<BBQCategory> categories = new ArrayList<BBQCategory>();

	private transient boolean errorFlag = false;

	public boolean isSoldOut(BBQCategory cat) {
		for (String mi : cat.getMenuItems()) {
			if (!isSoldOut(getMenuItem(mi))) {
				return false;
			}
		}
		return true;
	}

	public boolean isSoldOut(BBQMenuItem mi) {
		for (String ing : mi.getIngredients()) {
			if (getIngredient(ing).isSoldOut()) return true;
		}
		for (InterchangableIngredient inter : mi.getInterchangableIngredients()) {
			if (getStatus(inter) == Ingredient.SOLD_OUT) return true;
		}
		return false;
	}

	/** Returns whether this InterchangableIngredient is available, running low, or sold out */
	public int getStatus(InterchangableIngredient inter) {
		int bestStatus = Ingredient.SOLD_OUT;
		for (String ing : inter.getIngredients()) {
			// the interchangableIngredient assumes the most available status of its ingredients
			int stat = getIngredient(ing).getStatus();
			if (stat > bestStatus) bestStatus = stat;
			if (bestStatus == Ingredient.AVAILABLE) return bestStatus;
		}
		return bestStatus;
	}

	public void addIngredient(Ingredient ing) {
		if (!ingredients.contains(ing)) {
			ingredients.add(ing);
		}
		fireEvent(Event.ADD_INGREDIENT, ing);
	}

	public void addMenuItem(BBQMenuItem item) {
		if (!menuItems.contains(item)) {
			menuItems.add(item);
		}
		fireEvent(Event.ADD_ITEM, item);
	}

	public void addCategory(BBQCategory item) {
		if (!categories.contains(item)) {
			categories.add(item);
		}
		fireEvent(Event.ADD_CAT, item);
	}

	public void setName(Ingredient ing, String name) {
		String old = ing.getName();
		ing.setName(name);
		for (BBQMenuItem item : menuItems) {
			item.changeIngredientName(old, name);
		}
		fireEvent(Event.CHANGE_INGREDIENT, ing);
	}

	public void setName(BBQMenuItem item, String name) {
		String old = item.getName();
		item.setName(name);
		for (BBQCategory cat : categories) {
			cat.changeMenuItemName(old, name);
		}
		fireEvent(Event.CHANGE_ITEM, item);
	}

	public void setName(BBQCategory cat, String name) {
		String old = cat.getName();
		cat.setName(name);
		for (BBQMenuItem item : menuItems) {
			if (item.getCategory().equals(old)) {
				item.setCategory(name);
			}
		}
		fireEvent(Event.CHANGE_CAT, cat);
	}

	public List<Ingredient> getIngredients() {
		return Collections.unmodifiableList(ingredients);
	}

	public List<BBQMenuItem> getMenuItems() {
		return Collections.unmodifiableList(menuItems);
	}

	public Ingredient getIngredient(String name) {
		if (name == null) return null;
		for (Ingredient ing : ingredients) {
			if (name.equals(ing.getName())) {
				return ing;
			}
		}
		return null;
	}

	public BBQMenuItem getMenuItem(String name) {
		if (name == null) return null;
		for (BBQMenuItem ing : menuItems) {
			if (name.equals(ing.getName())) {
				return ing;
			}
		}
		return null;
	}

	public BBQCategory getCategory(String name) {
		if (name == null) return null;
		for (BBQCategory ing : categories) {
			if (name.equals(ing.getName())) {
				return ing;
			}
		}
		return null;
	}

	/** Returns a menu generated by reading the given json. If the json cannot be read for some reason, returns a new menu with the error flag set. */
	public static BBQMenu fromJSON(String json) {
		try {
			Gson obj = new Gson();
			BBQMenu menu = obj.fromJson(json, BBQMenu.class);
			return menu != null ? menu : new BBQMenu();
		} catch (JsonParseException e) {
			return new BBQMenu().setErrorFlag(true);
		}
	}

	public String toJSON() {
		try {
			Gson gson = new GsonBuilder().setPrettyPrinting().create();
			return gson.toJson(this);
		} catch (JsonParseException e) {
			errorFlag = true;
			fireEvent(Event.ERROR, e);
		}
		return "";
	}

	public void reset() {
		for (Ingredient ing : getIngredients()) {
			ing.status = ing.getDefaultStatus(); // set directly so that all the changes are not logged
		}
		fireEvent(Event.RESET, null);
	}

	private BBQMenu setErrorFlag(boolean state) {
		errorFlag = state;
		return this;
	}

	public boolean getErrorFlag() {
		return errorFlag;
	}

	@Override
	public String toString() {
		StringBuilder steve = new StringBuilder();
		steve.append("error flag? ").append(errorFlag).append('\n');
		steve.append("Ingredients:\n");
		for (Ingredient ing : ingredients) {
			steve.append(ing.getName()).append(": ").append(ing.isSoldOut() ? "Sold Out\n" : "In Stock\n");
		}
		steve.append("Menu Items:\n");
		for (BBQMenuItem mi : menuItems) {
			steve.append(mi.getName()).append(": ");
			if (isSoldOut(mi)) {
				steve.append("Sold Out");
			} else {
				steve.append(mi.getPrice());
			}
			steve.append("\n");
		}
		return steve.toString();
	}
}
